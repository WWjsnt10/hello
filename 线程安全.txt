线程安全：满足三个条件
1.多个线程同时访问时，其表现正常。
2.无论操作系统如何调度这些线程，无论这些线程的执行顺序如何交织。
3.调用端的代码无需额外的同步或其他协调动作。

为什么保证线程安全：
1.即将析构一个对象时，如何知道其他线程是否正在使用该对象的成员函数。
2.我在使用一个对象时，其他线程没有析构这个对象
3.调用一个对象之前，如何保证这个对象还存在，它的析构函数会不会碰巧执行到一半。

通过shared_ptr和weak_ptr智能指针来解决这个问题，可以有效解决观察者模式。

加锁放在构造函数中，解锁放在析构函数中。

关键点：对象创建不能泄露this指针：
1.不要在构造函数中注册任何回调
2.不在构造函数中把this指针传给跨线程对象
3.不把this指针泄露给其他对象

C++内存问题：
1.缓冲区溢出(buffer overrun);
2.空悬指针/野指针;
3.重复释放(double delete);
4.内存泄漏(memory leek);
5.不配对的new[]/delete;
6.内存碎片(memory fragmetation);
